<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM 面试题（一）]]></title>
    <url>%2F2019%2F08%2F30%2FJVM-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JVM 内存模型、Java 对象的创建过程 1. Java 内存模型Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域： 1.1 程序计数器程序计数器是一块较小的内存空间，可以看作是当前线程所执行的行号指示器。 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间计数器互补影响，独立存储，我们称这类内存区域为 线程私有 的内存。 程序计数器的主要作用 字节码通过改变程序计数器来依次读取指令来实现代码的流程控制 在多线程情况下，用来记录当前线程的执行位置 注意： 程序计数器是唯一一个不会出现 OOM 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 1.2 虚拟机栈与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。 Java 内存可以粗糙的分为 堆（Heap） 和 栈（Stack），其中栈就是虚拟机栈，或者说是虚拟机中的局部变量表部分。（实际上，Java 虚拟机栈是由一个一个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息等） 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用 Java 虚拟机会出现两种异常： StackOverFlowError： 若 Java 虚拟机栈的内存不允许动态扩展，当线程请求栈的深度大于虚拟机的最大深度时会出现 OutOfMemoryError：若 Java 虚拟机栈允许动态扩展，且线程请求栈时内存用完了，就会出现 如何调用方法？ Java 栈可类比为数据结构中的栈，每次函数调用都会有一个栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。 Java 方法有两种返回方式：return 和异常，不论哪种，栈帧都会被弹出。 1.3 本地方法栈和虚拟机所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈作为虚拟机使用到的 Native 方法。在 HotSpot 虚拟机和 Java 虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量，操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 SOF 和 OOM 两种异常。 1.4 堆Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。 Java 堆是垃圾收集器管理的主要区域，因此也被称为 GC 堆（Garbage Collected Heap）。 从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点就是 Eden、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。 上图所示的 eden 区，s0，s1 区都属于新生代，tentired 属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会 +1（Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1），当它的年龄增加到一定程度（默认为 15岁），机会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数：-XX:MaxTenuringThreshold 来设置。 1.5 方法区方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它还有一个别名叫 No-Heap 1.5.1 方法区和永久代的关系 方法区也被称为永久代 方法区和永久代的关系类似于 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现。 也就是说，永久代是 HosSpot 的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。 1.5.2 常用参数]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim 实用技巧（二）- 普通模式]]></title>
    <url>%2F2019%2F08%2F30%2Fvim-%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[普通模式是 vim 的自然放松状态，其他文本编辑器大部分时间都处于类似于 vim 插入模式的状态中。普通模式命令的强大，很大程度上源于他可以把操作符与动作结合在一起。 技巧7： 停顿时请移开画笔 对于不习惯 vim 的人来说，普通模式看上去是一种奇怪的缺省状态，但有经验的 vim 用户却很难想象还有其他任何方式。 你估计画家会花费多少时间用画笔在画布上作画？毫无疑问，这因人而异，但是，如果这占了画家全部工作时间的一半还要多的话，我会觉得非常诧异。 想一下除了画画外，画家还要做哪些事情。他们要研究主题，调整光线，把颜料混合成新的色彩。而且，在把颜料往画布上画时，谁说他们必须要用画笔？画家也许会换用刻刀来实现不同的质地，或是用棉签来对已经画好的地方进行润色。 画家在休息时不会把画笔放在画布上。对 vim 而言也是这样，普通模式就是 vim的自然放松状态，其名字已经寓示了这一点。 就像画家只花一小部分时间涂色一样，程序员也只花一小部分时间编写代码。绝大多数时间用来思考、阅读，以及在代码中穿梭浏览。而且，当确实需要做修改时，谁说一定要切换到插入模式才行？我们可以重新调整已有代码的格式，复制它们，移动其位置，或是删除它们。在普通模式中，我们有众多的工具可以利用。 技巧8： 把撤销单元切成块 在其他编辑器中，输入一些词后使用撤销命令，可能会撤销最后输入的词或字符。然而在 vim 中，我们可以自己控制撤销的粒度。 u 键会触发撤销命令，它会撤销最新的修改。一次修改可以是改变文档内文本的任意操作，其中包括在普通模式、可视模式以及命令行模式中所触发的命令，而且一次修改也包括了在插入模式中输入（或删除）的文本，因此我们可以说，i{insert some text}&lt;Esc&gt; 是一次修改。 在 vim 中，我们可以自己控制撤销命令的粒度。从进入插入模式开始，直到返回普通模式，在此期间输入或删除的任何内容都被视为一次修改。因此我们只需要控制好对 &lt;Esc&gt; 键的使用，就可以使撤销命令作用于单词、句子、段落。 在句尾停顿的时候，就可以使用 &lt;Esc&gt; 退出插入模式了。在准备好继续写的时候，按 A 命令就可以回到原来的地方继续写作。 当处于行尾的时候，另起一行的最快方式是按 &lt;CR&gt;，不过更好的方式是 &lt;Esc&gt;o，这样会以一行来控制撤销的粒度。 在插入模式中移动光标会重置修改状态 当使用了 &lt;Up&gt;、Down、Left、Right 这些光标键，将会产生一个新的撤销块，会对 u、. 等命令产生影响。 技巧9： 构造可重复的修改 vim 对重复操作进行了优化，要利用这一点，我们必须考虑该如何构造修改。 测试文本 我们要删除最后一个单词 nigh，假设光标已经在最后一个字符 h 上了 1The end is nigh 反向删除 db 命令从光标起始位置到单词开头的位置 x 删除 db 命令遗留下来的字符 h 这个操作的 vim 高尔夫得分是 3 分 正向删除 先使用 b 命令把光标移动到单词的开头 dw 命令删除一个单词 这个操作的 vim 高尔夫得分是 3 分 删除整个单词 我们可以使用更为精确的 aw 文本对象，而不是动作命令（详见：:h aw） 可以把 daw 解读为 delete a word 方便记忆 在技巧 51 和技巧 52 中会介绍更多关于文本对象的细节 3 分 哪种方法最具重复性？ 我们尝试了 3 种方法来删除一个词：dbx、bdw、daw。每种情况下的 vim 高尔夫得分都是 3 分。 很明显，daw 只有一个操作，最适合和 . 配合使用，而且 daw 命令还会删除一个空格。 技巧10： 用次数做简单的算术运算 大多数普通模式命令可以在执行时指定次数，我们可以利用这个功能来做简单的算术运算。 很多普通命令都可以带一个次数前缀，这样 vim 就会尝试把该命令执行指定的次数，而不是只执行一次（详见：:h count） &lt;C-a&gt;： 对数字执行加 &lt;C-x&gt;： 对数字执行减 在不带执行次数的时候，他们会逐个加减，但是如果加上前缀，就可以让他们加减任意整数，比如将光标移动到数字 5 上，执行 10&lt;C-a&gt; 就会把它变成 15。 如果光标不在数字上，&lt;C-a&gt; 命令 会把当前光标之上或之后的数值加上 [count]（详见：:h ctrl-a）。因此如果光标不在数字上，会在当前行正向查找一个数字，如果找到了，就直接跳转到那里。 12.blog, .news &#123; background-image: url(/sprite.png); &#125;.blog &#123; background-position: 0px 0px &#125; 我们想最后实现： 123.blog, .news &#123; background-image: url(/sprite.png); &#125;.blog &#123; background-position: 0px 0px &#125;.news &#123; background-position: -180px 0px &#125; 我们先使用 yyp 复制此行，然后使用 cw 修改第一个单词，然后再处理数值： 一种做法是用 f0 调到此数字，然后进入插入模式手动修改它的值，即 i-18&lt;Esc&gt; 更好的方法是 180&lt;c-x&gt; 在本例中，我们只复制了一行并做出改动。但是，假设你要复制 10 份，并对后续数字依次减 180。如果要切换到插入模式去修改每个数字，我们每次都得输入不同内容（-180，然后-360，以此类推）。但是如果用 180 命令的话，对后续行也可以采用相同的操作过程。我们甚至还可以把这组按键操作录制成一个宏（详见第 11章），然后根据需要执行多次。 数字的格式 007 的后面是什么？ 正确的答案是 010，像在某些编程语言中的约定一样，vim 把以 0 开头的数字解释为 8 进制，而不是 10 进制。如果你经常使用 8 进制，vim 的缺省行为或许会适合你，如果不是这样，在 vimrc 中，设置： 1set nrformats= 这样 vim 会把所有的数字都当作 10 进制，不管他们是不是以 0 开头的。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>reading</tag>
        <tag>note</tag>
        <tag>vim 实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim 实用技巧（一）- Vim 解决问题的方式]]></title>
    <url>%2F2019%2F08%2F29%2Fvim-%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本质上讲，我们的工作是重复性的。不论是在几个不同的地方做相同的小改动，还是在文档的相似结构间移动，我们都会重复很多操作。凡是可以简化重复性操作的方式，都会成倍地节省我们的时间。 技巧1： 结识 . 命令 . 命令可以让我们重复上次的修改 测试文本 12345$ cat test.txtLine oneLine twoLine threeLine four x 命令会删除光标下的字符，在这种情况下使用 . 命令 “重复上次修改” 时，就会让 Vim 删除光标下的字符： &gt;G 命令会增加从当前行到文档末尾处的缩进层级，如果我们在使用了此命令之后使用了 . 命令，那么 “重复上次修改” 会让 vim 增加从当前行到文档末尾的缩进层级： x， &gt; 命令都是在普通模式中执行的命令，不过，我们每次进入插入模式时，也会形成一次修改。从进入插入模式的那一刻起，直至返回普通模式，vim 会记录每一个按键操作。做出这样一个修改后再用 . 命令，它会重新执行所有这些按键的操作（参见技巧 8）。 . 是一个微型的宏 技巧2： 不要自我重复 对于在行尾添加内容这样常见的操作，如添加 ;，vim 专门提供了一个专门的命令，可以把两步操作合成一步 测试文件 123var foo = 1var bar = 'a'var foobar = foo + bar 在每一行的末尾添加分号 ; 普通方法 使用 $ 到行尾 使用 a 在光标之后插入 添加 ; Esc 退出插入模式 j $ . ： 此时 . 代替了三个键（a ; Esc） 减少不相关的移动 使用 A 代替 $ 和 a 一键移动，另一键操作，真是太完美了！请留意这种应用模式，因为我们即将在更多的例子中看到它的身影。 虽然这一模式对这个简短的例子来说很好用，但它不是万能的。试想一下，如果我们不得不给连续 50 行添加分号，即便每个修改输一次 j. ，看起来也是一项很繁重的工作。跳到技巧 30 可以看到另外一种解决方法。 技巧3： 以退为进 我们可以用一种常用的 vim 操作习惯在一个字符前后各添加一个空格。乍一看，这种方法比较古怪，不过好处是可以重复 测试文本 123var foo = "method("+argument1+","+argument2+")";// 需要改变为：var foo = "method(" + argument1 + "," + argument2 + ")"; 使移动可重复 f{char} 命令让 vim 查找下一处指定字符出现的位置，如果找到了，就直接把光标移动到那里（详细可见 :h f）。因此当我们输入 f+ 时，光标会直接移到下一个出现 + 的位置。我们将会在技巧 49 里学到更多关于 f{char} 命令的知识。 完成第一处修改后，可以直接重复按 f+ 去找下一个加号，不过 ; 命令会重复查找上次 f 命令所查找的字符，因此我们不用连续输入 4 次 f+，而是只用输入一次，剩下的直接输入 ; 就好了。 s 命令把两个操作合为一个：它先删除光标下的字符，然后进入插入模式。在删除 + 后，我们先输入 + ，然后退出插入模式。 先退一步，然后前进三步，看起来可能不够直接。但是这样做的最大的好处是：我们可以使用 . 命令重复这一修改操作。我们需要做的只是把光标移动到下一个 + 处，使用 . 命令重复这一操作即可。 技巧4： 执行、重复、返回 在面对重复性工作时，我们需要移动动作和修改动作都能够重复，这样就可以达到一个最佳的编辑模式。这样 vim 就可以记住我们的操作。本节是介绍这些可重复操作，并学习如何回退。 . 可以重复上次修改 @: 可以用来重复任意 ex 命令（在技巧 31 中讨论） &amp; 可以重复上一次的 :substitute 命令（参见技巧 92） 当 vim 让一个操作或移动可以很方便的重复时，它总是会提供某种方式，让我们在不小心做过头时能够回退，表 1-1 总结了 vim 中可重复执行的命令，以及相应的回退方式。 技巧5： 查找并手动替换 vim 提供了一个 :substitute 命令专门用于查找替换功能，不过用上面的技术，我们也可以手动修改第一个出现的地方，然后再一个一个的替换其他匹配项。 测试文本 在下面这段文本中，每一行都出现了单词 content 123...We&apos;re waiting for content before the site can go live......If you are content with this, let&apos;s go ahead with it......We&apos;ll launch as soon as we have the content... 假设我们想用单词 copy 来替代 content，其实很简单，只需要： 1:%s/content/copy/g 但是我们并不想所有的 content 都被替换成 copy，因为有的地方可能会出现语义错误。需要时刻留神，对每个地方都要问 这里需要修改吗？，subtitute 也能胜任这个工作（技巧 89），不过我们这里有另一种方法. 偷懒的办法： 无需输入就可以进行查找 * 命令可以查找当前光标下的单词（详见： :h *）。我们可以先直接查找 content 单词： 1/content 或者，简单的把光标放在这个单词上，然后按 * 键： 刚开始，把光标移动到 content 上，然后使用 * 命令，这样会产生两个结果： 光标会跳到下一个匹配项上 所有出现这个词的地方都会被高亮，如果没有高亮，需要设置 :set hls，详情可见技巧 80 执行过一次查找的命令之后，我们只需要按 n 就可以跳到下一个匹配项了，按 N 就是返回到上一次搜索的地方。 使修改可重复 当光标位于 content 的开头时，我们就可以开始修改了：需要删除这个单词，然后输入代替的词。cw 命令将这两步合成了一步。 因此只需要 cw copy Esc 就修改完成了，按 n 到下一个匹配处，考虑是否需要修改，需要修改的话就按 . 重复上一次修改。 技巧6： 结识 . 范式 到目前为止的三个简单的编辑任务，我们都使用了 . 命令解决了问题。 回顾前面三个 . 命令编辑任务 在技巧 2 中，我们想在一系列行的结尾添加分号。我们先用 A;&lt;Esc&gt;修改了第一行，做完这步准备后，就可以使用 . 命令对后续行重复此修改。我们使用了j命令在行间移动，要完成剩余的修改，只需简单地按足够多次 j.就可以了。 在技巧 3 中，我们想为每个+ 号的前后各添加一个空格。我们先用 f+ 命令跳到目标字符上，然后用 s 命令把一个字符替换成 3 个，做完这步准备后，我们就可以按若干次 ;. 完成此任务。 在技巧 5 中，我们想把每处出现单词 content 的地方都替换成 copy。我们使用 * 命令来查找目标单词，然后用 cw 命令修改第一处地方。做完这步准备后，就可以用 n 键跳到下一匹配项，然后用 . 键做相同的修改。要完成这项任务，只需简单地按足够多次 n. 就行了。 理想模式： 用一键移动，另一键执行 这些例子的共同点就是：用一键移动，另一键执行，为了方便起见，我们把它称作 . 范式。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>reading</tag>
        <tag>note</tag>
        <tag>vim 实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim 使用手册]]></title>
    <url>%2F2019%2F08%2F28%2Fvim-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 vim 的常用命令以及配置。 1. 正常模式1.1 光标移动 h、j、k、l： 分别对应着 ←、↓、↑、→ 字符移动 space ：向右移动一个字符 nspace：向右移动 n 个字符 backspace ：向左移动一个字符 nbackspace：向左移动 n 个字符 fo： 在当前行内下一个出现字母 o 的地方 Fo： 当前行内，上一个出现字母 o 的地方 ;： 配合 f、F、t、T 使用，到下一个搜索的地方 ,： 到上一个搜索的地方 单词移动 w： 向右移动一个词，定位在词首 W： 向右移动一个长单词，定位在词首 b： 向左移动一个词，定位在词首 B： 向左移动一个长单词，定位在词首 e：向右移动一个词，并且光标定位在词尾 E： 向右移动一个长单词，定位在词尾 行移动 ctrl+p： 向上移动一行 ctrl+n： 向下移动一行 Enter： 向下移动一行 nEnter： 向下移动 n 行 n+： 向下移动 n 行 n-： 向上移动 n 行 0 | ^ | &lt;Home&gt;： 到行首 $ | &lt;End&gt;： 到行尾 gg： 到第一行 G： 到最后一行 nG： 移动到第 n 行行首 H： 当前屏幕的顶行 M： 当前屏幕的中间行 L： 当前屏幕的底行 ctrl+o： 跳转到上次的地方 句、段移动 (： 到句首 )： 下一句的句首 {： 到段首 }： 到段尾 屏幕移动 ctrl+y： 向上滚屏 ctrl+e： 向下滚屏 ctrl+u： 向上滚动半屏 ctrl+d： 向下滚动半屏 ctrl+b： 向上滚动整屏 ctrl+f： 向下滚动整屏 zt： 将当前行变为屏幕第一行 zz： 将当前行变为中间行 zb： 将当前行变为尾行 1.2 操作编辑删除 x： 删除光标所在的一个字符 nx： 删除包括光标所在的字符的共 n 个字符 X： 删除光标之前的一个字符 nX： 删除光标之前的 n 个字符 D： 删除光标所在的字符至行尾 dw： 删除一个单词（在光标之后） ndw： 删除 n 个单词 d(： 删除至行首 d$： 删除至行尾 dd： 删除当前行 ndd： 删除包括当前行的 n 行 d(： 从光标位置删除到上一行行首 d)： 从光标位置删除到下一行行首 d{： 从光标位置删除到上一段开始所有字符 d}： 从光标位置删除到下一段开始所有字符 d回车: 删除当前行以及下一行 复制 yl： 复制光标所在的字符 nyl： 复制光标为首的 n 个字符 yw： 复制光标到词尾的字符 nyw： 复制 n 个字符 yy： 复制当前行 nyy： 复制 n 行 剪切 dd： 剪切当前行 ndd： 剪切 n 行 粘贴 p： 在光标之后粘贴 P： 在光标之前粘贴 撤销及重复 u： 撤销改动 .： 重复上一命令 ctrl+r | U： 重做 2. 插入模式 i： 在光标之前插入 a： 在光标之后插入 I： 在行首插入 A： 在行尾插入 o： 在当前行下面新开一行，插入 O： 在当前行上面新开一行，插入 cc： 删除当前行，并进入插入模式 s： 删除光标所在位置的字符并进入插入模式 3. 末行模式搜索 :/search： 从当前光标向下搜索指定字符串 :?search： 从当前行开始向上搜索指定字符串 n： 向下重复搜索 N： 向上重复搜索 替换 :s/source/replacement/： 将当前行出现第一个源字符串替换掉 :s/source/replacement/g： 将当前行的所有匹配字符串都替换掉 :1,2s/source/replacement/g： 将 1 到 2 行（包括 1 和 2 行）中的所有匹配字符串都替换 :1,$s/source/replacement/g： 将 1 行到最后一行的所有匹配字符串替换 :%s/source/replacement/g： 将文件中所有匹配字符串替换 :%s/source/replacement/gc： 每次替换之前都需要确认 复制 :1,2 co 3： 将 1 到 2 行之间的内容复制到第 3 行下面 :1,2 m 3： 将 1 到 2 行之间的内容移动到第 3 行下面 删除 :1,2 d： 删除 1 到 2 行之间的所有内容 :%d | :1,$d： 删除全部内容 保存 :w： 保存 :w!： 强制保存 :w /filename： 另存为 1,2w /filename： 将 1 到 2 行之间的内容另存为 :x | :wq： 保存并退出 :q： 退出不保存 :q!： 强制退出不保存 :wq!： 强制保存并退出 :e!： 放弃此次修改 选项 :set number： 是指是否显示行号 :set list： 显示制表符和行尾标志 :hlsearch： 是否开启高亮查找结果 4. 配置更多配置可以参考 learnvimscriptthehardway 我的配置： 12345678910111213141516171819202122232425" = 设置行号和选中行set numberset cursorline" = 设置 tab 宽度为 4set tabstop=4set softtabstop=4set smartindentset shiftwidth=4" = 设置编码格式set encoding=utf-8set fileencoding=utf-8set fileencodings=ucs-bom,utf-8,chinese,latin1" = 高亮代码syntax on" = 选中行在屏幕中上下至少有 5 行set scrolloff=5" = 在插入模式中，光标的样式变成和 word 一样的一个竖线 |let &amp;t_SI = "\&lt;Esc&gt;]50;CursorShape=1\x7"let &amp;t_SR = "\&lt;Esc&gt;]50;CursorShape=2\x7"let &amp;t_EI = "\&lt;Esc&gt;]50;CursorShape=0\x7"]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tool</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 常用命令之文本处理工具]]></title>
    <url>%2F2019%2F08%2F27%2Flinux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[linux 中常用的命令行工具，对文本进行处理，有 grep、cut、sort、uniq、tee、diff、paste、tr，其中最常用的就是 grep 和 cut 还有更牛逼的 ack。 1. grep grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来） 是一种强大的文本搜索工具，他能使用正则表达式搜索文本，并把匹配的行打印出来。 用于过滤/搜索的特定字符 可用正则表达式配合使用，使用十分灵活 常用选项1234567891011121314151617-i # 不区分大小写-v # 查找不包含指定行的内容，反向选择-w # 按单词搜索-o # 打印匹配关键字-n # 显示行号-r # 逐层遍历目录查找-A # 显示匹配行以及其后面多少行-B # 显示匹配行以及其前面多少行-C # 显示匹配行以及其前后多少行-l # 只列出匹配的文件名-L # 列出不匹配的文件名-e # 使用正则表达式-E # 使用扩展正则匹配^key # 以关键字开头key$ # 以关键字结尾^$ # 匹配空行--color=auto # 将关键字加上颜色 正则表达式12345678910111213141516^ # 锁定行的开始$ # 锁定行的结尾. # 匹配一个非换行符的字符* # 0 个或多个.* # 任意字符[] # 一个范围内的字符，[Gg] 表示 G 或 g[^] # 一定范围内以什么开头\(..\) # 标记匹配符，\(love\)，此时 love 就被标记为 1\&lt; # 锁定单词的开始，匹配包含这个单词的行\&gt; # 锁定单词的结尾x\&#123;m\&#125; # 重复字符 x，重复了 m 次x\&#123;m,\&#125; # 至少重复了 m 次x\&#123;m,n\&#125; # 重复了 m～n 次\w # 匹配文字和字符串，即 [A-Za-z0-9]\W # \w 的取反形式，匹配一个或多个非单词字符，比如点句号等\b # 单词锁定符，如 \bjojo\b 表示只匹配 jojo 常见用法在文件中搜索一个单词，命令会返回一个包含 “match_pattern” 的文本行： 12$ grep match_pattern file_name$ grep "match_pattern" file_name 在多个文件中查找： 1$ grep "match_pattern" file_1 file_2 file3 ... 输出除了目标之外的所有行： 1$ grep -v "match_pattern" file_name 使用正则表达式： 12$ grep -E "[1-9]+"$ egrep "[1-9]+" 只输出文件中匹配的部分，主要配合正则使用： 1$ echo this is a test line. | grep -o -E "[a-z]+\." 统计文件或文件中包含匹配字符串的行数： 1$ grep -c "text" file_name 输出包含匹配字符串的行数： 12$ grep "text" -n file_name$ cat file_name | grep "text" -n 打印样式匹配所位于的字符或字节偏移： 1$ echo gun is not unix | grep -b -o "not" 搜索多个文件并查找匹配文本在哪些文件中： 1$ grep -l "text" file1 file2 file3 ... 递归搜索文件在多级目录中对文本进行递归搜索： 1$ grep "text" ./ -r -n 忽略大小写： 1$ echo "hello world" | grep -i "HELLO" 选项 -e 可以匹配多个样式： 1$ echo this is a text line | grep -e "is" -e "line" -o 也可以使用 -f 来匹配多个样式，使用的是样式文件： 1234$ cat patfileaaabbb$ echo aaa bbb ccc ddd eee | grep -f patfile -o 在 grep 搜索结果中包括或排除指定文件： 12345678# 只在目录中所有的 .php 和 .html 文件中递归搜索字符 "main()"$ grep "main()" . -r --include *.&#123;php,html&#125;# 在搜索结果中排除所有的 README 文件$ grep "main()" . -r --exclude "README"# 在搜索结果中排除 filelist 文件列表中的文件$ grep "main()" . -r --exclude-from filelsit 使用 0 值字节的后缀的 grep 与 xargs： 1234567# 测试文件$ echo "aaa" &gt; file1$ echo "bbb" &gt; file2$ echo "ccc" &gt; file3$ grep "aaa" file* -lZ | xargs -0 rm# 执行后会删除 file1 和 file3，grep 的 -Z 选项是用来指定以 0 值字节为终结的文件名，xargs -0 读取输入并用 0 值字节终结符分割文件名，然后删除匹配文件 显示匹配到行之前多少行，之后多少行： 1234$ seq 10 | grep 5 -A 3$ seq 10 | grep 5 -B 3$ seq 10 | grep 5 -C 3# 如果匹配结果有多个，中间会以 -- 作为分隔符 2. cut 用于列的截取 用于连接文件 常用选项123-c # 以字符为单位进行分割截取-d # 自定义分隔符，默认为制表符 \t-f # 与 -d 一起使用，指定截取哪个区域 常见用法123456$ cut -d: -f1 test.text # 以 : 为分隔符的第一列内容$ cut -d: -f1,6,7 test.text # 以 : 为分隔符，第 1、6、7 列的内容$ cut -c4 test.txt # 截取文件每行中的第 4 个字符$ cut -c1-4 test.txt # 截取每行中的 1~4 个字符$ cut -c5- test.txt # 截取每行从第 5 个字符开始$ cut -c-2 test.txt # 截取每行的前面两个字符 实例1234567891011$ cat test.txtNo Name Mark Precent01 tom 69 9102 jack 71 8703 alex 68 98$ cut -f2,3 test.txtName Marktom 69jack 71alex 68]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
</search>
