<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vim 使用技巧（一）- Vim 解决问题的方式]]></title>
    <url>%2F2019%2F08%2F29%2Fvim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本质上讲，我们的工作是重复性的。不论是在几个不同的地方做相同的小改动，还是在文档的相似结构间移动，我们都会重复很多操作。凡是可以简化重复性操作的方式，都会成倍地节省我们的时间。 技巧1： 结识 . 命令 . 命令可以让我们重复上次的修改 测试文本 12345$ cat test.txtLine oneLine twoLine threeLine four x 命令会删除光标下的字符，在这种情况下使用 . 命令 “重复上次修改” 时，就会让 Vim 删除光标下的字符： &gt;G 命令会增加从当前行到文档末尾处的缩进层级，如果我们在使用了此命令之后使用了 . 命令，那么 “重复上次修改” 会让 vim 增加从当前行到文档末尾的缩进层级： x， &gt; 命令都是在普通模式中执行的命令，不过，我们每次进入插入模式时，也会形成一次修改。从进入插入模式的那一刻起，直至返回普通模式，vim 会记录每一个按键操作。做出这样一个修改后再用 . 命令，它会重新执行所有这些按键的操作（参见技巧 8）。 . 是一个微型的宏 技巧2： 不要自我重复 对于在行尾添加内容这样常见的操作，如添加 ;，vim 专门提供了一个专门的命令，可以把两步操作合成一步 测试文件 123var foo = 1var bar = 'a'var foobar = foo + bar 在每一行的末尾添加分号 ; 普通方法 使用 $ 到行尾 使用 a 在光标之后插入 添加 ; Esc 退出插入模式 j $ . ： 此时 . 代替了三个键（a ; Esc） 减少不相关的移动 使用 A 代替 $ 和 a 一键移动，另一键操作，真是太完美了！请留意这种应用模式，因为我们即将在更多的例子中看到它的身影。 虽然这一模式对这个简短的例子来说很好用，但它不是万能的。试想一下，如果我们不得不给连续 50 行添加分号，即便每个修改输一次 j. ，看起来也是一项很繁重的工作。跳到技巧 30 可以看到另外一种解决方法。 技巧3： 以退为进 我们可以用一种常用的 vim 操作习惯在一个字符前后各添加一个空格。乍一看，这种方法比较古怪，不过好处是可以重复 测试文本 123var foo = "method("+argument1+","+argument2+")";// 需要改变为：var foo = "method(" + argument1 + "," + argument2+")"; 使移动可重复 f{char} 命令让 vim 查找下一处指定字符出现的位置，如果找到了，就直接把光标移动到那里（详细可见 :h f）。因此当我们输入 f+ 时，光标会直接移到下一个出现 + 的位置。我们将会在技巧 49里学到更多关于 f{char} 命令的知识。 完成第一处修改后，可以直接重复按 f+ 去找下一个加号，不过 ; 命令会重复查找上次 f 命令所查找的字符，因此我们不用连续输入 4 次 f+，而是只用输入一次，剩下的直接输入 ; 就好了。 s 命令把两个操作合为一个：它先删除光标下的字符，然后进入插入模式。在删除 + 后，我们先输入 + ，然后退出插入模式。 先退一步，然后前进三步，看起来可能不够直接。但是这样做的最大的好处是：我们可以使用 . 命令重复这一修改操作。我们需要做的只是把光标移动到下一个 + 处，使用 . 命令重复这一操作即可。 技巧4： 执行、重复、返回]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>reading</tag>
        <tag>note</tag>
        <tag>vim 使用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim 使用手册]]></title>
    <url>%2F2019%2F08%2F28%2Fvim-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 vim 的常用命令以及配置。 1. 正常模式1.1 光标移动 h、j、k、l： 分别对应着 ←、↓、↑、→ 字符移动 space ：向右移动一个字符 nspace：向右移动 n 个字符 backspace ：向左移动一个字符 nbackspace：向左移动 n 个字符 fo： 在当前行内下一个出现字母 o 的地方 Fo： 当前行内，上一个出现字母 o 的地方 ;： 配合 f、F、t、T 使用，到下一个搜索的地方 ,： 到上一个搜索的地方 单词移动 w： 向右移动一个词，定位在词首 W： 向右移动一个长单词，定位在词首 b： 向左移动一个词，定位在词首 B： 向左移动一个长单词，定位在词首 e：向右移动一个词，并且光标定位在词尾 E： 向右移动一个长单词，定位在词尾 行移动 ctrl+p： 向上移动一行 ctrl+n： 向下移动一行 Enter： 向下移动一行 nEnter： 向下移动 n 行 n+： 向下移动 n 行 n-： 向上移动 n 行 0 | ^ | &lt;Home&gt;： 到行首 $ | &lt;End&gt;： 到行尾 gg： 到第一行 G： 到最后一行 nG： 移动到第 n 行行首 H： 当前屏幕的顶行 M： 当前屏幕的中间行 L： 当前屏幕的底行 ctrl+o： 跳转到上次的地方 句、段移动 (： 到句首 )： 下一句的句首 {： 到段首 }： 到段尾 屏幕移动 ctrl+y： 向上滚屏 ctrl+e： 向下滚屏 ctrl+u： 向上滚动半屏 ctrl+d： 向下滚动半屏 ctrl+b： 向上滚动整屏 ctrl+f： 向下滚动整屏 zt： 将当前行变为屏幕第一行 zz： 将当前行变为中间行 zb： 将当前行变为尾行 1.2 操作编辑删除 x： 删除光标所在的一个字符 nx： 删除包括光标所在的字符的共 n 个字符 X： 删除光标之前的一个字符 nX： 删除光标之前的 n 个字符 D： 删除光标所在的字符至行尾 dw： 删除一个单词 ndw： 删除 n 个单词 d(： 删除至行首 d$： 删除至行尾 dd： 删除当前行 ndd： 删除包括当前行的 n 行 d(： 从光标位置删除到上一行行首 d)： 从光标位置删除到下一行行首 d{： 从光标位置删除到上一段开始所有字符 d}： 从光标位置删除到下一段开始所有字符 d回车: 删除当前行以及下一行 复制 yl： 复制光标所在的字符 nyl： 复制光标为首的 n 个字符 yw： 复制光标到词尾的字符 nyw： 复制 n 个字符 yy： 复制当前行 nyy： 复制 n 行 剪切 dd： 剪切当前行 ndd： 剪切 n 行 粘贴 p： 在光标之后粘贴 P： 在光标之前粘贴 撤销及重复 u： 撤销改动 .： 重复上一命令 ctrl+r | U： 重做 2. 插入模式 i： 在光标之前插入 a： 在光标之后插入 I： 在行首插入 A： 在行尾插入 o： 在当前行下面新开一行，插入 O： 在当前行上面新开一行，插入 cc： 删除当前行，并进入插入模式 s： 删除光标所在位置的字符并进入插入模式 3. 末行模式搜索 :/search： 从当前光标向下搜索指定字符串 :?search： 从当前行开始向上搜索指定字符串 n： 向下重复搜索 N： 向上重复搜索 替换 :s/source/replacement/： 将当前行出现第一个源字符串替换掉 :s/source/replacement/g： 将当前行的所有匹配字符串都替换掉 :1,2s/source/replacement/g： 将 1 到 2 行（包括 1 和 2 行）中的所有匹配字符串都替换 :1,$s/source/replacement/g： 将 1 行到最后一行的所有匹配字符串替换 :%s/source/replacement/g： 将文件中所有匹配字符串替换 :%s/source/replacement/gc： 每次替换之前都需要确认 复制 :1,2 co 3： 将 1 到 2 行之间的内容复制到第 3 行下面 :1,2 m 3： 将 1 到 2 行之间的内容移动到第 3 行下面 删除 :1,2 d： 删除 1 到 2 行之间的所有内容 :%d | :1,$d： 删除全部内容 保存 :w： 保存 :w!： 强制保存 :w /filename： 另存为 1,2w /filename： 将 1 到 2 行之间的内容另存为 :x | :wq： 保存并退出 :q： 退出不保存 :q!： 强制退出不保存 :wq!： 强制保存并退出 :e!： 放弃此次修改 选项 :set number： 是指是否显示行号 :set list： 显示制表符和行尾标志 :hlsearch： 是否开启高亮查找结果 4. 配置更多配置可以参考 learnvimscriptthehardway 我的配置： 12345678910111213141516171819202122232425" = 设置行号和选中行set numberset cursorline" = 设置 tab 宽度为 4set tabstop=4set softtabstop=4set smartindentset shiftwidth=4" = 设置编码格式set encoding=utf-8set fileencoding=utf-8set fileencodings=ucs-bom,utf-8,chinese,latin1" = 高亮代码syntax on" = 选中行在屏幕中上下至少有 5 行set scrolloff=5" = 在插入模式中，光标的样式变成和 word 一样的一个竖线 |let &amp;t_SI = "\&lt;Esc&gt;]50;CursorShape=1\x7"let &amp;t_SR = "\&lt;Esc&gt;]50;CursorShape=2\x7"let &amp;t_EI = "\&lt;Esc&gt;]50;CursorShape=0\x7"]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>linux</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 常用命令之文本处理工具]]></title>
    <url>%2F2019%2F08%2F27%2Flinux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[linux 中常用的命令行工具，对文本进行处理，有 grep、cut、sort、uniq、tee、diff、paste、tr，其中最常用的就是 grep 和 cut 还有更牛逼的 ack。 1. grep grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来） 是一种强大的文本搜索工具，他能使用正则表达式搜索文本，并把匹配的行打印出来。 用于过滤/搜索的特定字符 可用正则表达式配合使用，使用十分灵活 常用选项1234567891011121314151617-i # 不区分大小写-v # 查找不包含指定行的内容，反向选择-w # 按单词搜索-o # 打印匹配关键字-n # 显示行号-r # 逐层遍历目录查找-A # 显示匹配行以及其后面多少行-B # 显示匹配行以及其前面多少行-C # 显示匹配行以及其前后多少行-l # 只列出匹配的文件名-L # 列出不匹配的文件名-e # 使用正则表达式-E # 使用扩展正则匹配^key # 以关键字开头key$ # 以关键字结尾^$ # 匹配空行--color=auto # 将关键字加上颜色 正则表达式12345678910111213141516^ # 锁定行的开始$ # 锁定行的结尾. # 匹配一个非换行符的字符* # 0 个或多个.* # 任意字符[] # 一个范围内的字符，[Gg] 表示 G 或 g[^] # 一定范围内以什么开头\(..\) # 标记匹配符，\(love\)，此时 love 就被标记为 1\&lt; # 锁定单词的开始，匹配包含这个单词的行\&gt; # 锁定单词的结尾x\&#123;m\&#125; # 重复字符 x，重复了 m 次x\&#123;m,\&#125; # 至少重复了 m 次x\&#123;m,n\&#125; # 重复了 m～n 次\w # 匹配文字和字符串，即 [A-Za-z0-9]\W # \w 的取反形式，匹配一个或多个非单词字符，比如点句号等\b # 单词锁定符，如 \bjojo\b 表示只匹配 jojo 常见用法在文件中搜索一个单词，命令会返回一个包含 “match_pattern” 的文本行： 12$ grep match_pattern file_name$ grep "match_pattern" file_name 在多个文件中查找： 1$ grep "match_pattern" file_1 file_2 file3 ... 输出除了目标之外的所有行： 1$ grep -v "match_pattern" file_name 使用正则表达式： 12$ grep -E "[1-9]+"$ egrep "[1-9]+" 只输出文件中匹配的部分，主要配合正则使用： 1$ echo this is a test line. | grep -o -E "[a-z]+\." 统计文件或文件中包含匹配字符串的行数： 1$ grep -c "text" file_name 输出包含匹配字符串的行数： 12$ grep "text" -n file_name$ cat file_name | grep "text" -n 打印样式匹配所位于的字符或字节偏移： 1$ echo gun is not unix | grep -b -o "not" 搜索多个文件并查找匹配文本在哪些文件中： 1$ grep -l "text" file1 file2 file3 ... 递归搜索文件在多级目录中对文本进行递归搜索： 1$ grep "text" ./ -r -n 忽略大小写： 1$ echo "hello world" | grep -i "HELLO" 选项 -e 可以匹配多个样式： 1$ echo this is a text line | grep -e "is" -e "line" -o 也可以使用 -f 来匹配多个样式，使用的是样式文件： 1234$ cat patfileaaabbb$ echo aaa bbb ccc ddd eee | grep -f patfile -o 在 grep 搜索结果中包括或排除指定文件： 12345678# 只在目录中所有的 .php 和 .html 文件中递归搜索字符 "main()"$ grep "main()" . -r --include *.&#123;php,html&#125;# 在搜索结果中排除所有的 README 文件$ grep "main()" . -r --exclude "README"# 在搜索结果中排除 filelist 文件列表中的文件$ grep "main()" . -r --exclude-from filelsit 使用 0 值字节的后缀的 grep 与 xargs： 1234567# 测试文件$ echo "aaa" &gt; file1$ echo "bbb" &gt; file2$ echo "ccc" &gt; file3$ grep "aaa" file* -lZ | xargs -0 rm# 执行后会删除 file1 和 file3，grep 的 -Z 选项是用来指定以 0 值字节为终结的文件名，xargs -0 读取输入并用 0 值字节终结符分割文件名，然后删除匹配文件 显示匹配到行之前多少行，之后多少行： 1234$ seq 10 | grep 5 -A 3$ seq 10 | grep 5 -B 3$ seq 10 | grep 5 -C 3# 如果匹配结果有多个，中间会以 -- 作为分隔符 2. cut 用于列的截取 用于连接文件 常用选项123-c # 以字符为单位进行分割截取-d # 自定义分隔符，默认为制表符 \t-f # 与 -d 一起使用，指定截取哪个区域 常见用法123456$ cut -d: -f1 test.text # 以 : 为分隔符的第一列内容$ cut -d: -f1,6,7 test.text # 以 : 为分隔符，第 1、6、7 列的内容$ cut -c4 test.txt # 截取文件每行中的第 4 个字符$ cut -c1-4 test.txt # 截取每行中的 1~4 个字符$ cut -c5- test.txt # 截取每行从第 5 个字符开始$ cut -c-2 test.txt # 截取每行的前面两个字符 实例1234567891011$ cat test.txtNo Name Mark Precent01 tom 69 9102 jack 71 8703 alex 68 98$ cut -f2,3 test.txtName Marktom 69jack 71alex 68]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
