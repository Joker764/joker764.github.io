---
title: JVM 面试题（一）
date: 2019-08-30 20:59:13
tags: 
  - java
  - 面试
  - jvm
categories: Java
---

JVM 内存模型、Java 对象的创建过程、对象的访问定位、判断对象，常量，类是否还有用...

<!--more-->

## 1. Java 内存模型

Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域：

![](https://github.com/Joker764/joker764.github.io/blob/src/images/interview/1-2.png?raw=true)

### 1.1 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的行号指示器。

字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间计数器互补影响，独立存储，我们称这类内存区域为 *线程私有* 的内存。

**程序计数器的主要作用**

- 字节码通过改变程序计数器来依次读取指令来实现代码的流程控制
- 在多线程情况下，用来记录当前线程的执行位置

> 注意： 程序计数器是唯一一个不会出现 `OOM` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### 1.2 虚拟机栈

与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

Java 内存可以粗糙的分为 堆（Heap） 和 栈（Stack），其中栈就是虚拟机栈，或者说是虚拟机中的局部变量表部分。（实际上，Java 虚拟机栈是由一个一个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息等）

局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用

Java 虚拟机会出现两种异常：

- `StackOverFlowError`： 若 Java 虚拟机栈的内存不允许动态扩展，当线程请求栈的深度大于虚拟机的最大深度时会出现
- `OutOfMemoryError`：若 Java 虚拟机栈允许动态扩展，且线程请求栈时内存用完了，就会出现

**如何调用方法？**

Java 栈可类比为数据结构中的栈，每次函数调用都会有一个栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java 方法有两种返回方式：`return` 和异常，不论哪种，栈帧都会被弹出。

### 1.3 本地方法栈

和虚拟机所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈作为虚拟机使用到的 Native 方法。在 HotSpot 虚拟机和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量，操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 SOF 和 OOM 两种异常。

### 1.4 堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

Java 堆是垃圾收集器管理的主要区域，因此也被称为 GC 堆（Garbage Collected Heap）。

从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点就是 `Eden`、`From Survivor`、`To Survivor` 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。

![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3%E5%A0%86%E7%BB%93%E6%9E%84.png)

上图所示的 `eden` 区，`s0`，`s1` 区都属于新生代，`tentired` 属于老年代。大部分情况，对象都会首先在 `Eden` 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 `s0` 或者 `s1`，并且对象的年龄还会 `+1`（Eden 区 -> Survivor 区后对象的初始年龄变为 1），当它的年龄增加到一定程度（默认为 15岁），机会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数：`-XX:MaxTenuringThreshold` 来设置。

### 1.5 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它还有一个别名叫 `No-Heap`

#### 1.5.1 方法区和永久代的关系

> 方法区也被称为永久代

方法区和永久代的关系类似于 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现。

也就是说，永久代是 HosSpot 的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。

#### 1.5.2 常用参数

- `-XX:MetaspaceSize=n`：设置 MetaSpace 的初始大小（最小大小）
- `-XX:MaxMetaspaceSize=n`：MetaSpace 的最大大小

#### 1.5.3 为什么要将永久代（PermGen）替换为元空间（MetaSpace）呢？

整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间是直接使用内存，受本机可用内存的限制，并且永远不会得到 OOM 异常。

这只是其中一个原因。

### 1.6 运行时常量

运行时常量是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外、还有常量池信息（用于存放编译器生成的各种字面量和符号引用）

既然运行时常量池也是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OOM 异常。

**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

![](https://images.xiaozhuanlan.com/photo/2019/02276bcccbe181985ac50af2668940c9.jpg)

### 1.7 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。**

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## 2. Java 对象的创建过程

### 2.1 类加载检查

虚拟机遇到一条 `new` 命令，首先去检查这个指令参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过、解析和初始化过。如果没有，就必须执行相应的类加载过程。

### 2.2 分配内存

在类加载检查通过后，接下来虚拟机将为新生对象分配内存，对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。

分配方式有 **指针碰撞** 和 **空闲列表** 两种，选择哪种分配方式由 Java 堆是否规定决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

#### 2.2.1 内存分配的两种方式

选择以上两种方式的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存的规整取决于 GC 收集器的算法是 **标记-清除**，还是 **标记-整理**，值得注意的是，复制算法内存也算是规整的

![](https://images.xiaozhuanlan.com/photo/2019/3af6db384fba7d42e2f9a07fb57b72d8.)

#### 2.2.2 分配内存并发问题

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- CAS + 失败重试：CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性**
- TLAB：为每一个线程预先在 Eden 区分配一块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中剩余内存或 TLAB 的内存已经用尽时，再采用上述的 CAS 进行分配

### 2.3 初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

### 2.4 设置对象头

初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

### 2.5 执行 init 方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已近产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 `new` 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 3. 对象的访问定位方式

> 建立对象就是为了使用对象，我们 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有

### 3.1 句柄

使用句柄的话，在 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

![](https://images.xiaozhuanlan.com/photo/2019/eea6f944dd5d522a079b43d409f620d7.png)

### 3.2 直接指针

使用了 直接指针访问，在 Java 堆对象的布局中就必须考虑如何防止访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址

![](https://images.xiaozhuanlan.com/photo/2019/242ab9b89650e22c816ebdeea7311ac5.png)

这两种对象的访问各有优势：

使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。

使用直接指针的最大好处是速度块，节省了一次指针定位的时间开销。

## 4. Minor GC 和 Full GC 的区别

大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

- 新生代 GC（Minor GC）：只发生在新生代的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快
- 老年代 GC（Major GC/Full GC）：只发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Full GC（并非绝对），Major GC 的速度一般会比 Minor GC 的速度慢 10 倍以上。

## 5. 判断对象是否死亡

> 堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）

### 5.1 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就 `+1`，当引用失败就 `-1`，任何时候计数器为 0 的对象就是不可能再被使用的。

### 5.2 可达性分析算法

这个算法的基本思想就是通过一系列的称为 `GC Roots` 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 `GC Roots` 没有任何引用链相连的话，就证明此对象是不可用的。

![](https://images.xiaozhuanlan.com/photo/2019/7ba1179cfa1bba68f85cd7538256a5a1.jpg)

## 6. 对象的引用

> 无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判断对象的存活都与 `引用` 有关。

- JDK 1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个 `引用`
- JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为 `强引用`、`软引用`、`弱引用`、`虚引用` 四种（引用强度逐渐减弱）

### 6.1 强引用（Strong Reference）

以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。

如果一个独享具有强引用，那就类似于必不可少的生活永平，垃圾回收器绝对不会回收它。当内存空间不足时，Java 虚拟机宁愿 OOM，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

### 6.2 软引用（Soft Reference）

如果一个对象只有软引用，那就类似于可有可无的生活用品。如果内存的空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（Reference Queue）联合使用，如果软引用所引用的对象被垃圾回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。

### 6.3 弱引用（Weak Reference）

如果一个对象只具有弱引用，那就类似于可有可无的生活用品。

弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

弱引用也可以和引用队列联合使用。

### 6.4 虚引用（Phantom Reference）

`虚引用` 顾名思义，就是形同虚设，与其他几种引用不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

**虚引用主要用来跟踪对象被垃圾回收的活动。**

**虚引用与软引用和弱引用的一个区别在于：**

虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

## 7. 判断常量是否废弃

> 运行时常量池主要回收的是废弃的常量，那么如何判断常量的废弃呢？

假如在常量池中存在字符串 `"abc"`，如果当前没有任何 `String` 对象引用该字符串常量的话，就说明常量 `"abc"` 就是废弃常量，如果这时候发生内存回收的话而且有必要的话，`"abc"` 就会被系统清理出常量池。

## 8. 判断类是否无用

> 无用的类是由方法区回收

判断一个常量是否是 **废弃变量** 比较简单，但判断一个类是否是 **无用的类** 的条件比较苛刻：

- 该类所有的实例都已经被回收，也就是说 Java 堆中不存在该类的任何实例
- 加载该类的 `ClassLoader` 已经被回收
- 该类对应的  `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过发射访问该类的方法

虚拟机**可以**对满足上述 3 个条件的无用类进行回收，并不是**一定**。

