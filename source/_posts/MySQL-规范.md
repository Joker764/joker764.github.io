---
title: MySQL 规范
date: 2019-09-05 17:05:56
tags:
  - mysql
  - 规范
categories: SQL
---

<!--more-->

## 1. 数据库命名规范

- 所有数据库对象名称必须使用小写字母并用下划线分割
- 禁止使用保留字段
- 命名要能做到见名识意，并且最后不要超过 32 个字符
- 临时库表必须以 `tmp_` 为前缀，以日期为后缀
- 备份表必须使用 `bak_` 为前缀并以日期（时间戳）为后缀
- 所有存储相同数据的列名和列类型必须一致

## 2. 数据库基本设计规范

**1. 所有表必须使用 InnoDB 存储引擎**

没有特殊要求（即 `InnoDB` 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 `InnoDB` 存储引擎（MySQL 5.5 之前默认使用 `MyISAM`，5.6 以后默认的为 `InnoDB`）。

`InnoDB` 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。

**2. 数据库和表的字符集统一使用 UTF8**

兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 `utf8mb4` 字符集。

**3. 所有字段和表都需要添加注释**

使用 `comment` 从句添加表和列的备注，从一开始就进行数据字典的维护。

**4. 尽量控制表单数据量的大小，建议控制在 500 万以内**

500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。

可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小。

**5. 谨慎使用 MySQL 分区表**

- 分区表在物理上表现为多个文件，在逻辑上表现为一个表
- 谨慎选择分区键，跨分区查询效率可能更低
- 建议采用物理分表的方式管理大数据

**6. 尽量做到冷热数据分离，减小表的宽度**

> MySQL 限制每个表最多存储 4096 列，并且没一行数据的大小不能超过 65535 字节

- 减少磁盘 I/O，保证热数据的内存缓存命中率（表越宽，加入到内存缓存中的速度越慢，占用内存也更大）
- 更有效的利用缓存
- 经常一起使用的列放到一个表中

**7. 禁止在表中建立预留字段**

- 预留字段的命名很难做到见名识义
- 预留字段无法确认存储的数据类型，所以无法选择合适的类型
- 对预留字段类型的修改，会对表进行锁定

**8. 禁止在数据库中存储文件，图片等大的二进制数据**

- 通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。
- 通常存储于文件服务器，数据库只存储文件地址信息

**9. 禁止在线上做数据库压力测试**

**10. 禁止从开发环境，测试环境直接生成环境数据库**

## 3. 数据库字段设计规范

- 优先选用符合条件的最小数据类型
- 避免使用 `TEXT`，`BLOB` 数据类型，最常见的 `TEXT` 类型可以存储 64k 的数据
- 避免使用 `ENUM` 类型
- 尽可能把所有列定义为 `NOT NULL`
- 使用 `TIMESTAMP`（4 个字节）或 `DATETIME` （8 个字节）存储时间
- 同财务相关的金额类数据必须使用 `DECIMAL` 类型

## 4. 索引设计规范

- 限制单表上的索引个数，一般不超过 5 个
- 禁止给表中的每一列都建立单独索引
- 每个 `InnoDB` 表必须有主键
- 常见建立索引的列：
  - 出现在 `SELECT`、`UPDATE`、`DELETE` 语句的 `WHERE` 从句中的列
  - 包含在 `GROUP BY`、`ORDER BY`、`DISTINCT` 中的字段
  - 通常将上面两种情况的字段建立联合索引
  - 多表 `JOIN` 的关联列
- 选择索引的顺序：
  - 区分度最高的放在联合索引的最左侧（区分度 = 列中不同值的数量 / 列的总行）
  - 尽量把字段长度小的列放在最左侧
  - 使用最频繁的列放在左侧
- 避免重复索引和冗余索引：
  - 重复索引：`primary key(id)`、`index(id)`、`unique index(id)`
  - 冗余索引：`index(a, b, c)`、`index(a, b)`、`index(a)`
- 对于频繁的查询优先考虑覆盖索引
- 索引 `SET` 规范：
  - 尽量避免使用外键约束
  - 外键会降低父表和子表的写操作而降低性能
  - 尽量在业务功能上实现外键功能

## 5. SQL 开发规范

- 建议使用预编译语句进行数据库操作
- 避免数据类型的隐式转换，会带来索引失效
  - `SELECT name, phone FROM customer WHERE id = '111'`
- 充分利用表上已经创建的索引
- 数据库设计时，要考虑后续的扩展
- 程序连接不同的数据库使用不同的账号，进行跨库查询
  - 为数据库迁移和分库分表留出余地
  - 降低业务耦合
  - 避免权限过大而产生的安全风险
- 禁止使用 `SELECT *` 
- 禁止使用不含字段的 `INSERT` 语句
  - 错误：`INSERT INTO t VALUES('a', 'b', 'c')`
  - 正确：`INSERT INTO t(c1, c2, c3) VALUES ('a', 'b', 'c')`
- 避免使用子查询，因为无法使用索引
- 避免使用 `JOIN` 关联太多的表
- 减少同数据库的交互操作
- 对同一列进行 `OR` 判断时，使用 `IN` 替代 `OR`，因为 `IN` 能有效的利用索引
- 禁止使用 `ORDER BY rand()` 进行随机排序
- `WHERE` 从句中禁止对列进行函数转换和计算：
  - 错误：`WHERE date(create_time) = '20191001'`
  - 正确：`WHERE create_time >= '20191001' AND create_time < '20190102'`
- 在明显不会有重复值时使用 `UNION ALL` 而不是 `UNION`
  - `UNION` 会把两个结果集的所有数据放到临时表中再去进行去重操作
  - `UNION ALL` 不会对结果集进行去重操作
- 拆分复杂的大 SQL 分为多个小 SQL

## 6. 数据库操作行为规范

**超过 100 万行的批量写操作（`UPDATE`、`INSERT`、`DELETE`）要分批多次进行操作**

- 大批量操作可能会造成严重的主从延迟
- `binlog` 日志为 `row` 格式时会产生大量日志
- 避免产生大事务操作

**对于大表使用 `pt-online-schema-change` 修改表结构**

- 避免大表修改产生的主从延迟
- 避免在对表字段进行修改时进行锁表

**禁止为程序使用的账号赋予 super 权限**

- 当达到最大连接数限制时，还运行一个有 super 权限的用户连接
- super 权限只能留给 DBA 处理问题的账号使用
- 程序使用数据库账号只能在一个 DB 下使用，不准跨库
- 程序使用的账号原则上不准有 `DROP` 权限