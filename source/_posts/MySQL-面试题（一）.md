---
title: MySQL 面试题（一）
date: 2019-09-05 14:04:54
tags:
  - 面试
  - mysql
  - innodb
categories: SQL
---

<!--more-->

## 1. 什么是 MySQL？

`MySQL` 是一种关系型数据库，在 Java 企业级开发中十分常用，因为 MySQL 是开源免费的，并且方便扩展。阿里巴巴数据库系统也大量用到了 MySQL，因此它的稳定系是有保障的。

MySQL 是开源的，因此任何人都可以在 GPL（General Public License） 的许可下下载并根据个性化的需求对其进行修改。

## 2. 事务相关

### 2.1 什么是事务？

事务是逻辑上的一组操作，要么都执行，要么都不执行。

### 2.2 事务的四大特性

![](https://images.xiaozhuanlan.com/photo/2019/00049f25e8453b5adb5f1bcac4797d79.png)

- 原子性：事务最小的执行单位，不允许分割
- 一致性：执行事务前后，数据保持一致，多个事务对同一个数据的读取结果是相同的
- 隔离性：并发访问数据时，一个用户的事务不被其它事务干扰，各个并发事务之间数据库是独立的
- 持久性：一个事务被提交后，它对数据库中数据的改变是持久的，即使数据库发生故障也不会对其影响

### 2.3 并发事务带来的影响

- 脏读：一个事务读取到了另一个事务正在修改还没有提交的数据
- 不可重复读：一个事务多次读取同一数据，在读取过程中，另一个事务对其进行了修改，造成了多次读取数据不一样
- 幻读：在读取过程中，另外的事务插入了一些数据，就会发现了一些好像不存在的东西
- 丢失修改：两个事务同时修改一个数据，都是 `-1`，本来结果应该是两个`-1`，也就是  `-2`，但是却是 `-1`

### 2.4 MySQL 事务的隔离级别

- 读未提交：最低的隔离级别，允许读取未提交的数据
- 读已提交：允许读取事务已经提交的数据
- 可重复读：对同一字段的多次读取结果是一致的，除非数据被本身事务修改
- 串行化：最高的隔离级别，完全服从 ACID，所有事务依次执行

| 隔离级别        | 脏读 | 不可重复读 | 幻读 |
| --------------- | :--: | :--------: | :--: |
| READ-UNCOMMITED |  √   |     √      |  √   |
| READ-COMMITED   |  ×   |     √      |  √   |
| REPEATABLE-READ |  ×   |     ×      |  √   |
| SERIALIZABLE    |  ×   |     ×      |  ×   |

> MySQL InnoDB 默认支持的是 REPEATABLE-READ

```mysql
mysql> SELECT @@tx_isolation
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
```

与 SQL 标准不同的地方在于 `InnoDB` 存储引擎在 `REPEATABLE-READ` 事务隔离级别下使用的是 `Next-Key Lock` 锁算法，因此可以避免幻读的产生，这与其他数据库系统（如：SQL Server）是不同的。

所以说 `InnoDB` 存储引擎的默认支持的隔离级别是`REPEATABLE-READ` 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 `SERIALIZABLE` 隔离级别。



因为隔离级别越低，事务请求的锁就越少，所以大部分数据库系统的隔离级别都是 `READ-COMMITED`，但是 `InnoDB` 默认使用的 `REPEATABLE-READ` 并不会有任何性能损失。

`InnoDB` 存储引擎在分布式事务的情况下一般会用到 `SERIALIZABLE` 隔离级别。

## 3. 索引相关

### 3.1 为什么要使用索引

- 通过创建唯一性索引，可以保证表中每一行数据的唯一性
- 可以大大加快数据的检索速度（大大减少检索的数据量），**这是主要原因**
- 帮助服务器避免排序和临时表
- 将随机 IO 变为顺序 IO
- 可以加速表和表之间的连接

### 3.2 索引是越多越好吗？

- 当表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了维护速度
- 索引需要占物理空间
- 创建索引和维护索引需要时间

### 3.3 MySQL 的基本存储结构

![](https://images.xiaozhuanlan.com/photo/2019/53fb4b0ab69f265fc87d2644b6ec16e9.jpg)

![](https://images.xiaozhuanlan.com/photo/2019/6221ec727fc769fcd43c1cb8e84eac8c.jpg)

- 每个数据页可以组成一个双向链表
- 每个数据页中的记录又可以组成一个单向链表
- 每个数据页都会为存储在其中的记录生产一个页目录，通过主键查找会比较快
- 以其他列（非主键）搜索的时候，只能从最小的开始遍历

### 3.4 索引是如何提高查询速度的

- 改变数据结构，将无序变为有序

![](https://images.xiaozhuanlan.com/photo/2019/bcc5199d6a4e4f29351af6e2189410a3.jpg)

找到 id 为 8 的记录：

![](https://images.xiaozhuanlan.com/photo/2019/d101732ebc32f1e92480fe4b90ce933d.jpg)

很明显：没有索引，我们就需要遍历双向链表，现在通过 **目录** 就可以很快定位了。

### 3.5 使用索引的注意事项

- 在经常需要搜索的列上创建索引
- 在经常使用 `WHERE` 子句的列上面加索引
- 再经常需要排序的列上创建索引
- 对于中型到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引
- 避免在 `WHERE` 子句中对字段施加函数，这回造成无法命中索引
- 在使用 `InnoDB` 的时候使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务组件
- 将打算加索引的列设置为 `NOT NULL`，否则会导致引擎放弃使用索引而进行全表索引
- 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗，在 `sys` 库的 `chema_unused_indexes` 中可查询（5.7 之后）
- 在使用 `LiIMIT` `OFFSET` 查询缓慢时，可以借助索引来提高性能

### 3.6 索引的主要数据结构

- 哈希索引：底层数据结构是哈希表，在绝大多数需求为单条记录查询的情况下可以使用
- BTree 索引：底层是 B+ 树，`MyISAM` 和 `InnoDB` 底层实现会有不同

**MyISAM**

`B+ Tree` 页节点的 `data` 域存放的是数据记录的地址。在索引检索的时候，首先按 `B+ Tree` 的搜索算法搜索索引，如果指定的 key 存在，取出其 `data` 域的值，然后以 `data` 域的值为地址读取相应的数据记录。这被称为 **非聚簇索引**

**InnoDB**

- 其数据文件本身就是索引文件，与 `MyISAM` 相比，索引文件和数据文件是分离的，其表数据文件本身就是按照 `B+ Tree` 组织的一个索引结构
- 树的叶节点 `data` 域保存了完整的数据记录
- 这个索引的 `key` 是数据的主键，因此 `InnoDB` 表数据文件本身就是主索引，这被称为 **聚簇索引**
- 其他索引都作为辅助索引，辅助索引的 `data` 域存放是相应主键的值而不是地址
- 因此在设计表的时候，不建议使用过长的字段作为主键

### 3.7 覆盖索引

> 如果一个索引包含所有需要查询的字段的值，我们就称之为 **覆盖索引**

我们知道在 `InnoDB` 中，如果不是主键索引，叶子节点存储的是主键+列值，最终还是要 **回表**，也就是通过主键再索引一次，这样就会比较慢，覆盖索引就是把要查询出来的列和索引是对应的，不做回表操作。

比如：

- 创建了索引 `username`  `age`
- 查询的时候 `SELECT username, age FROM user WHERE username = 'JoJo' AND age = 22`
- 需要查询的数据的列都在，就不需要回表

### 3.8 索引查询原则

- 单行访问是很慢的，特别是在机械硬盘存储中（SSD 的随机 I/O 要快很多，不过这一点仍然成立），如果服务器从存储中读取一个数据块只是为了获取其中的一行，那么就浪费了很多工作，最好读取的块中能尽量包含更多需要的行。使用索引可以创建位置索引，用以提升效率。
- 按顺序访问范围数据是很快的
  - 顺序 I/O 不需要多次磁盘寻道，所以比随机 I/O 要快很多（特别是对机械硬盘）
  - 如果服务器能够按需要顺序读取数据，就不需要额外的排序操作，并且 `GROUP BY` 查询也能更快
- 索引覆盖查询是很快的

## 4. 左前缀原则

MySQL 中的索引可以以一定的顺序引用多列，这种索引叫做联合索引。如 `User` 表的 `name` 和 `city` 创建了联合索引 `(name, city)`，而左前缀原则是指：如果查询的时候查询精确匹配条件的索引是左边连续一列或几列，则这几列都可以被用到：

```sql
SELECT * FROM User WHERE name = xx AND city = xx;    // 可以命中索引
SELECT * FROM User WHERE city = xx AND name = xx;    // 可以命中索引
SELECT * FROM User WHERE name = xx;                  // 可以命中索引
SELECT * FROM User WHERE city = xx;                  // 不能命中索引
```

- 这里，第二中情况，如果条件都用上了，但是顺序不同，查询引擎会自动优化顺序
- 由于左前缀原则，在创建联合索引的时候，索引字段的顺序需要考虑字段值去重之后的个数，较多的放在前面，`ORDER BY` 也要遵循这个原则

## 5. 避免冗余索引

冗余索引是指索引功能相同，能够命中那一个这个就一定能命中，那么就是冗余索引。

在大多数情况下，都尽量扩展已有的索引而不是创建新索引。

MySQL 5.7 后的版本，可以通过 `sys` 库中的 `schema_redundant_indexes` 表来查看冗余索引。

## 6. 添加索引

**主键索引（PRIMARY KEY）**

```sql
ALTER TABLE `table_name` ADD PRIMARY KEY (`column`)
```

**唯一索引（UNIQUE）**

```sql
ALTER TABLE `table_name` ADD UNIQUE (`column`)
```

**普通索引（INDEX）**

```sql
ALTER TABLE `table_name` ADD INDEX index_name (`column`)
```

**全文索引（FULLTEXT）**

```sql
ALTER TABLE `table_name` ADD FULLTEXT (`column`)
```

**多列索引**

```sql
ALTER TABLE `table_name` ADD INDEX index_name (`column1`, `column2`, `column3`)
```

## 7. MyISAM 与 InnoDB的区别

`MyISAM` 是 `MySQL` 的默认数据库引擎（5.5 版本之前），由早期的 `ISAM`（Indexed Sequential Access Method，有索引的顺序访问方法）所改良。虽然性能极佳，而且提供了大量的特性，包括：全文索引、压缩、空间函数等，但 `MyISAM` 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。

大多数时候我们使用的都是 `InnoDB` 存储引擎，但是在某些情况下使用 `MyISAM` 也是合适的，比如：读密集的情况下。

> 不要轻易相信 `MyISAM` 比 `InnoDB` 快之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，`InnoDB` 的速度都可以让 `MyISAM`望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。            —— 《MySQL 高性能》

一般情况下我们选择 `InnoDB` 都是没有问题的，但是某事情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 `MyISAM` 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。

## 8. 乐观锁与悲观锁

### 8.1 悲观锁

总是做最坏的打算，每次拿数据都会认为别人会修改，所以每次拿数据的时候都会加上锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java 中 `synchronized` 和 `ReentrantLock` 等独占锁就是悲观锁思想的实现。

### 8.2 乐观锁

总是做最好的打算，每次拿数据都会认为别人不会修改。但是在更新的时候会判断一下再此期间别人修改过这个数据没有，可以使用版本号机制和 `CAS` 算法实现。

乐观锁适用于多读的应用类型，可以提高吞吐量。

像数据库提供的类似于 `write_condition` 机制，其实都是提供的乐观锁。在 Java 中 `java.util.concurrent.atomic` 包下面的原子变量类就是使用了乐观锁的一种实现方式 `CAS` 实现的。

### 8.3 使用场景

- 乐观锁：写较少，多读
- 悲观锁：写较多

### 8.4 乐观锁的实现方式

**版本号机制**

一般是在数据表中加入一个数据版本号 `version` 字段，表示数据被修改的次数，当数据被修改时 `+1`。当线程要更新数据值的时候，在读取数据的同时也会读取 `version` 值，在提交更新时，需要刚才读到的 `version` 值与当前数据库中的 `version` 值相同时才更新。否则就 `rollback`。

**CAS 算法**

即 `compare and swap`，是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程阻塞的情况下实现变量的同步，所以也叫非阻塞同步，CAS 算法涉及的三个操作数：

- 需要读写的内存值 `V`
- 进行比较的值 `A`
- 插入的新值 `B`

当且 `V` 的值等于 `A` 时，CAS 通过原子方式用新增 `B` 的值来更新 `V` 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自选操作，即不断的重试。

### 8.5 乐观锁的缺点

**ABA 问题**

如果一个变量 `V` 初次读取的值是 `A`，并且在准备赋值的时候检查到他还是 `A`，这段时间它的值可能被改为其他值，又被改回 `A`，这个时候 CAS 会认为它从来没有被修改过。

JDK 1.5 以后的 `AtomicStampedReference` 类就提供了此种能力，其中的 `compareAndSet` 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

**循环时间长开销大**

自旋 CAS 如果长时间不成功，会给 CPU 带来很大的开销。

如果JVM能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。

**只能保证一个共享变量的原子操作**

CAS 只对单个共享变量有效，当操作涉及多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了 `AtomicReference` 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用 `AtomicReference` 把多个共享变量合并成一个共享变量来操作。

## 9. 锁机制与 InnoDB 锁算法

- `MyISAM` 采用表级锁（table-level locking）
- `InnoDB` 支持行级锁（row-level locking）和表级锁，默认为行级

- 表级锁：MySQL 中锁定粒度最大的一种锁，加锁快，不会出现死锁。并发最低，触发锁冲突的概率最高
- 行级锁：MySQL 中锁定粒度最小的一种锁，并发高，开销大，加锁满，会出现死锁

**InnoDB 锁算法**

- `Record Lock`：单个行记录上的锁
- `Gap Lock`：间隙锁，锁定一个范围，不包括记录本身
- `Next-key Lock`：`record` + `gap` 锁定一个范围，包含记录本身

**相关知识点**

1. `InnoDB` 对于行的查询使用 `next-key lock`
2. `Next-locking keying` 为了解决 `Phantom Problem` 幻读问题
3. 当查询的索引含有唯一属性时，将 `next-key lock` 降级为 `record key`
4. `Gap` 锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
5. 有两种方式显式关闭 `gap` 锁：（除了外键约束和唯一性检查外，其余情况仅使用 `record lock`） 
   1. 将事务隔离级别设置为 RC 
   2. 将参数 `innodb_locks_unsafe_for_binlog` 设置为 `1`

## 10. 大表优化

### 10.1 限定数据的范围

务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

### 10.2 读写分离

经典的数据库拆分方案，主库负责写，从库负责读；

### 10.3 垂直分区

**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 

![](https://images.xiaozhuanlan.com/photo/2019/aa62487e11b370755df5e16bcc7330b8.png)

- **垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
- **垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；

#### 10.4 水平分区

**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。**

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

![](https://images.xiaozhuanlan.com/photo/2019/8d5aff7c0cf502863faf1cd4c1dbc73d.png)

水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。

水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

**下面补充一下数据库分片的两种常见方案：**

- **客户端代理：** **分片逻辑在应用端，封装在jar包中，通过修改或者封装 JDBC 层来实现。** 当当网的 **Sharding-JDBC** 、阿里的 TDDL 是两种比较常用的实现。
- **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。

## 11. 一条 SQL 在 MySQL 中是如何执行的

### 11.1 MySQL 基本架构

简单来说 MySQL 主要分为 Server 层和存储引擎层：

- Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
- 存储引擎： 主要负责数据的存储和读取，采用可以替换的插件式架构。

![](https://github.com/Joker764/joker764.github.io/blob/src/images/interview/2-1.png?raw=true)

- 连接器：身份认证和权限相关
- 查询缓存：执行查询语句的时候，会先查询缓存（MySQL 8.0 后移除）
- 分析器：没有命中缓存，SQL 语句就会经过分析器，就是看你要干嘛，再看你语法对不对
- 优化器：按照 MySQL 认为最优方案去执行
- 执行器：执行语句，然后从存储引擎返回数据