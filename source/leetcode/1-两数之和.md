---
title: 1. 两数之和
date: 2019-09-03 17:04:11
tags:
  - 算法
  - leetcode
  - array
  - hash-table
categories:
  - leetcode
---

> leetcode 中的 abandon

难度：[简单](https://joker764.github.io/leetcode/difficulty/easy.html)
标签：[数组](https://joker764.github.io/leetcode/tag/array.html)，[哈希表](https://joker764.github.io/leetcode/tag/hash-table.html)
题目：[two-sum](https://leetcode-cn.com/problems/two-sum/)

## 题目

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

## 示例

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

## 思路

- 标签：哈希映射
- 本身通过暴力解法，时间复杂度也只有 `O(n2)`
- 由于哈希查找算法的时间复杂度为 `O(1)`，所以可以利用哈希容器来降低时间复杂度
- 遍历数组 `nums`，`i` 为当前下标，每个值都判断 `map` 中是否存在 `target-nums[i]` 的 key 值

## 解法

### 暴力解法

**Java**

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

**Python**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        length = len(nums)
        for i in range(length):
            for j in range(i + 1, length):
                if nums[i] + nums[j] == target:
                    return [i, j]
```

- 时间复杂度：`O(n2)`
- 空间复杂度：`O(1)`

### 哈希表

**Java**

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i< nums.length; i++) {
            if(map.containsKey(target - nums[i])) {
                return new int[] {map.get(target-nums[i]),i};
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

**Python**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashmap = {}
        for i,value in enumerate(nums):
            complement = target - value
            if complement in hashmap:
                return {hashmap[complement], i}
            hashmap[value] = i
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

## 图解

![1](https://pic.leetcode-cn.com/146e209493728cd7b9fd6095c5947300732799db9b28b2f8e497525ea7b31d58-Messages%20Image(1369442164).png)

![2](https://pic.leetcode-cn.com/d54dcd98bf9b8f5f5575893a9c253dda04cb177436322a9b41ce89290deb651d-Messages%20Image(3072076888).png)

![3](https://pic.leetcode-cn.com/c486f3ff7e4b810dd228acad621aa76899eb39b053723d663fc0359dc1d85fac-Messages%20Image(645062534).png)

![4](https://pic.leetcode-cn.com/89121495efbd8b51444cf5a4a1326073e1bd801cd7070a4d82a6897d3c86ba9f-Messages%20Image(2668429756).png)